/**
 * Implicit Scope: a scoped derived atom has implicitly scoped dependencies.
 * Explicit Scope: atoms passed to the ScopeProvider are explicitly scoped.
 * Explicit overrides implicit scoped.
 * Nested scope overrides parent scope.
 *
 * Scope is a copy of the atom and the getter is to look at the current scope
 * and up the scope chain for x
 *
 * Does implicit vs explicit scope matter? No.
 */

/**
 * Thes scopeMaps are used to map the original atom to the scoped atom.
 * explicit - atom is passed to ScopeProvider atoms prop at that scope level (Highest priority)
 * implicit - atom is scoped because it is a dependency of a scoped derived atom (Medium priority)
 * inherited - atom is scoped because it is scoped in the parent scope (Lowest priority)
 */

/*
  explicit > implicit > inherited > unscoped derived > original
  _if they are explicitly scoped, then return explicitly scoped_

  ** inherited scoped atoms preserve their value from the parent scope **


  a -> b -> c
  {
    explicit: a
    implicit: b,c
    inherited: none
    derived: none
    original: none
  }
  <ScopeProvider atoms={[a]} level="1">
    {
      explicit: none
      implicit: none
      inherited: a,b,c
      derived: none
      original: none
    }
    a1 -> b1 -> c1
    <ScopeProvider atoms={[b]} level="2">
      {
        explicit: c
        implicit: none
        inherited: a,b
        derived: none
        original: none
      }
      <ScopeProvider atoms={[c]} level="3">
        <Component />
      </ScopeProvider>
    </ScopeProvider>
  </ScopeProvider>

  l2: a1 -> b0
          -> b1
          -> b2
      a2 -> b0
          -> b1
          -> b2

  if the atom is explicitly scoped
    if the dependency is already explicitly scoped, return the explicitly scoped atom
    if the dependency is already implicitly scoped, return the implicitly scoped atom
    if the dependency is already inherited scoped, return the inherited scoped atom
    if the atom is explicitly scoped, its dependencies are implicitly scoped
    
*/

/**
 * When an atom is accessed via useAtomValue/useSetAtom, the access should
 * be handled by getAtom.
 */
